/*
 * generated by Xtext 2.10.0
 */
package jp.pizzafactory.modeling.dsl.vstepngt.ngtext.serializer;

import com.google.inject.Inject;
import java.util.Set;
import jp.pizzafactory.modeling.dsl.vstepngt.ngtext.services.LanguageGrammarAccess;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import vstepngt.Abstraction;
import vstepngt.Aggregation;
import vstepngt.Container;
import vstepngt.TestAssociation;
import vstepngt.Testable;
import vstepngt.VstepngtPackage;

@SuppressWarnings("all")
public class LanguageSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private LanguageGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == VstepngtPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case VstepngtPackage.ABSTRACTION:
				sequence_Abstraction(context, (Abstraction) semanticObject); 
				return; 
			case VstepngtPackage.AGGREGATION:
				sequence_Aggregation(context, (Aggregation) semanticObject); 
				return; 
			case VstepngtPackage.CONTAINER:
				if (rule == grammarAccess.getWorkspaceElementRule()
						|| rule == grammarAccess.getComponentRule()
						|| rule == grammarAccess.getContainerRule()) {
					sequence_Container(context, (Container) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getWorkspaceRootRule()) {
					sequence_WorkspaceRoot(context, (Container) semanticObject); 
					return; 
				}
				else break;
			case VstepngtPackage.TEST_ASSOCIATION:
				sequence_TestAssociation(context, (TestAssociation) semanticObject); 
				return; 
			case VstepngtPackage.TESTABLE:
				sequence_Testable(context, (Testable) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     WorkspaceElement returns Abstraction
	 *     Abstraction returns Abstraction
	 *
	 * Constraint:
	 *     (name=Identifiable? superClass=[Testable|ID] subClass=[Testable|ID])
	 */
	protected void sequence_Abstraction(ISerializationContext context, Abstraction semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     WorkspaceElement returns Aggregation
	 *     Aggregation returns Aggregation
	 *
	 * Constraint:
	 *     (name=Identifiable? stereotype=Stereotype? owner=[Component|ID] member=[Testable|ID])
	 */
	protected void sequence_Aggregation(ISerializationContext context, Aggregation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     WorkspaceElement returns Container
	 *     Component returns Container
	 *     Container returns Container
	 *
	 * Constraint:
	 *     (name=Identifiable? title=Title? (elements+=WorkspaceElement elements+=WorkspaceElement*)?)
	 */
	protected void sequence_Container(ISerializationContext context, Container semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     WorkspaceElement returns TestAssociation
	 *     TestAssociation returns TestAssociation
	 *
	 * Constraint:
	 *     (name=Identifiable? stereotype=Stereotype? type=AssociationType source=[Testable|ID] target=[Testable|ID])
	 */
	protected void sequence_TestAssociation(ISerializationContext context, TestAssociation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     WorkspaceElement returns Testable
	 *     Component returns Testable
	 *     Testable returns Testable
	 *
	 * Constraint:
	 *     (isRoot?='root'? name=Identifiable? shortDescription=ShortDescription?)
	 */
	protected void sequence_Testable(ISerializationContext context, Testable semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     WorkspaceRoot returns Container
	 *
	 * Constraint:
	 *     (elements+=WorkspaceElement elements+=WorkspaceElement*)
	 */
	protected void sequence_WorkspaceRoot(ISerializationContext context, Container semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
